#include "DanProcessor.h"

<<<<<<< HEAD
bool DanProcessor::Menu_DanProcesses_NegateImage(Image& image)
{
  static unsigned char memory[3][256] = {{0},{0},{0}};
  static bool lookup_table = false;

  // Build the lookup table
  if (!lookup_table)
  {
    for (int i = 0; i < 3; i++)
      for (int j = 0; j < 256; j++)
        memory[i][j] = 255 - (unsigned char) j;
    lookup_table = true;
  }

  if (image.IsNull()) return false;

  int rows = image.Height();
  int cols = image.Width();

=======
bool DanProcessor::Menu_DanFunctions_Negate(Image& image)
{
  if (image.IsNull())
    return false;
  
  int rows = image.Height();
  int cols = image.Width();
  
  unsigned char lutable[255] = {0};
  
  // Build lookup table
  for (int i = 0; i < 255; i++)
    lutable[i] = 255-i;
  
  for (int i = 0; i < rows; i++)
  {
    for (int j = 0; j < cols; j++)
    {
      // Negate each pixel
      image[i][j].SetRGB((lutable[image[i][j].Red()]),
                         (lutable[image[i][j].Green()]),
                         (lutable[image[i][j].Blue()]));
    }
  }
  
  return true;
}

bool DanProcessor::Menu_DanFunctions_Grayscale(Image& image)
{
  if (image.IsNull())
    return false;
  
  int rows = image.Height();
  int cols = image.Width();
  
  int gray;
  
  for (int i = 0; i < rows; i++)
  {
    for (int j = 0; j < cols; j++)
    {
      // Calculate weighted averages
      gray = image[i][j].Red() * 30;
      gray += image[i][j].Green() * 59;
      gray += image[i][j].Blue() * 11;
      gray /= 100;
      
      // Set gray value
      image[i][j].SetGray(gray);
    }
  }
  
  return true;
}

bool Menu_DanFunctions_BinaryThreshold(Image& image)
{
  if (image.IsNull())
    return false;
  
  int rows = image.Height();
  int cols = image.Width();
  
  int threshold;
  unsigned char lutable[255] = {0};
  
  // Propt user for threshold value
  if (!Dialog("Binary Threshold").Add(threshold, "Threshold", 0, 255).Show())
    return false;
  
  // Convert image to grayscale
  if (!Menu_DanFunctions_Grayscale(image))
    return false;
  
  // Build lookup table
  for (int i = 0; i < 255; i++)
    lutable[i] = (i < threshold ? 0 : 255);
  
>>>>>>> bc10c62cea9fe874e687def38037d4fddb6c0ef6
  for (int i = 0; i < rows; i++)
  {
    for (int j = 0; j < cols; j++)
    {
<<<<<<< HEAD
      image[i][j].SetRed(memory[0][image[i][j].Red()]);
      image[i][j].SetGreen(memory[1][image[i][j].Green()]);
      image[i][j].SetBlue(memory[2][image[i][j].Blue()]);
    }
  }

  return true;
}
=======
      // Perform binary thresholding
      image[i][j].SetGray(lutable[image[i][j].Red()]);
    }
  }
  
  return true;
}

bool Menu_DanFunctions_Posterize(Image& image)
{
  if (image.IsNull())
    return false;
  
  int rows = image.Height();
  int cols = image.Width();
  
  int levels;
  unsigned char lutable[255] = {0};
  
  // Propt user for threshold value
  if (!Dialog("Posterize Levels").Add(levels, "Levels", 0, 255).Show())
    return false;
  
  // Build lookup table
  for (int i = 0; i < 255; i++)
    lutable[i] = (unsigned char) (i / (256.0 / levels));
  
  for (int i = 0; i < rows; i++)
  {
    for (int j = 0; j < cols; j++)
    {
      // Posterize each color, truncating down
      image[i][j].SetRGB((lutable[image[i][j].Red()]),
                         (lutable[image[i][j].Green()]),
                         (lutable[image[i][j].Blue()]));
    }
  }
  
  return true;
}

bool Menu_DanFunctions_Brighten(Image& image)
{
  return false;
}

bool Menu_DanFunctions_LinearContrast(Image& image)
{
  return false;
}

>>>>>>> bc10c62cea9fe874e687def38037d4fddb6c0ef6
